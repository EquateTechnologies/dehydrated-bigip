#!/bin/bash

# pull in conf.d files
for i in ${BASEDIR}/conf.d/*.sh ; do
  . ${i}
done

## Programs
CURL="/usr/bin/curl"
LOGFILE=${LOGFILE:-'/var/log/dehydrated-bigip-deploy-management-certificate.log'}

# IP address or hostname to BIG-IP management interface
BIGIP_DEVICE=${BIGIP_DEVICE:-$2}
# Username to access BIG-IP iControl REST API
BIGIP_USERNAME=${BIGIP_USERNAME:-'admin'}
# Password for user to access BIG-IP iControl REST API
BIGIP_PASSWORD=${BIGIP_PASSWORD:-'admin'}
# if 1 enable OCSP stapling
OCSP_STAPLE=${OCSP_STAPLE:-1}
# if 1 save config after changes, e.g. equivalent to tmsh save sys config
BIGIP_SAVE_CONFIG=${BIGIP_SAVE_CONFIG:-1}

# Initial Curl connection timeout value in seconds.
TIMEOUT=${TIMEOUT:-5}
## Maximum time for an API call to return. Depending on what you are doing,
##  this value should be quite large as some calls take a long time to
##  complete!  Testing your script should provide you with a good ideal
##  about what is too long.  I usually start at 120 seconds and go up from there.
MAXTIMEOUT=${MAXTIMEOUT:-120}

####### START F5CommonRESTAPIs.sh #######

#  Sample F5 BIGIP Reset Configuration script
#  John D. Allen
#  April, 2016
#
#-----------------------------------------------------------------------------------
# Software is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
#
# The Initial Developer of the Original Code is F5 Networks,
# Inc. Seattle, WA, USA. Portions created by F5 are Copyright (C) 2016 F5 Networks,
# Inc. All Rights Reserved.
#
# Author: John D. Allen, Solution Architect, F5 Networks
# Email: john.allen@f5.com
#-----------------------------------------------------------------------------------
# This file contains a number of common iControl REST API functions that are used
# by the other bash scripts.
#

#-------------------------------------------------------
# Function: log()
#-------------------------------------------------------
DATE='date +%m/%d/%Y:%H:%M:%S'
log() {
  echo `$DATE`" $*" >> $LOGFILE
}

#-------------------------------------------------------
# Function: restCall()
#-------------------------------------------------------
restCall() {
  # $1 => Type (GET, PUT, POST, DELETE, PATCH, etc.)
  # $2 => URL past 'mgmt'  Example: "/tm/security/firewall/policy/~Common~TestPolicy1" for
  #       https://10.147.29.215/mgmt/tm/security/firewall/policy/~Common~TestPolicy1
  # $3 => JSON payload, if any.

  CONTTYPE='-H Content-Type: application/json'
  AUTH="--user $BIGIP_USERNAME:$BIGIP_PASSWORD"
  TIME="--connect-timeout $TIMEOUT"
  MAXTIME="-m $MAXTIMEOUT"
  URL="https://$BIGIP_DEVICE/mgmt$2"
  if [[ $1 == POST || $1 == PATCH || $1 == PUT ]]; then
    log "restCall():${CURL} -sk ${TIME} ${MAXTIME} ${CONTTYPE} ${AUTH} ${URL} -X $1 -d \"$3\""
    ${CURL} -sk ${TIME} ${MAXTIME} ${CONTTYPE} ${AUTH} ${URL} -X $1 -d "$3"
  else
    log "restCall():${CURL} -sk ${TIME} ${MAXTIME} ${CONTTYPE} ${AUTH} ${URL} -X $1 "
    ${CURL} -sk ${TIME} ${MAXTIME} ${CONTTYPE} ${AUTH} ${URL} -X $1
  fi
}

#-------------------------------------------------------
# Function:  jsonq()
#   Extract JSON key value. Example:
#   {
#    "generation": 1,
#    "items": [
#        {
#            "active": true,
#            "build": "0.0.606",
#            "generation": 1
#        }
#     [,
#   }
# ... | jsonq '["items"][0]["active"]'
# True
#-------------------------------------------------------
jsonq() {
  python -c "import sys,json; input=json.load(sys.stdin); print input$1"
}

#-------------------------------------------------------
# Function: saveConfig()
#-------------------------------------------------------
saveConfig() {
  OUT=$(restCall "POST" "/tm/sys/config" '{"command": "save"}')
  log "saveConfig(): `echo $OUT | python -mjson.tool`"
  if [[ $(echo $OUT | jsonq '["kind"]') != "tm:sys:config:savestate" ]]; then
    echo "ERROR! Configuration Save was not successful."
    return 1
  fi
  return 0
}

#-------------------------------------------------------
# Function: runBashCommand()
#-------------------------------------------------------
runBashCommand() {
  log "runBashCommand()[command]: ${1}"

  OUT=$(restCall "POST" "/tm/util/bash" "{\"command\": \"run\", \"utilCmdArgs\": \"-c \\\"${1}\\\"\"}")
  log "runBashCommand(): `echo $OUT | python -mjson.tool`"
  if [[ $(echo $OUT | jsonq '["kind"]') != "tm:util:bash:runstate" ]]; then
    echo "ERROR! Command was not successful."
    return 1
  fi
  return 0
}

#-------------------------------------------------------
# Function: modifyHttpdConfig()
#-------------------------------------------------------
modifyHttpdCerts() {
  log "modifyHttpdConfig()[command]: ${1} ${2}"

  OUT=$(restCall "PATCH" "/tm/sys/httpd" "{\"sslCertfile\": \"${1}\", \"sslCertkeyfile\": \"${2}\"}")
  log "modifyHttpdCerts(): `echo $OUT | python -mjson.tool`"
  if [[ $(echo $OUT | jsonq '["sslCertfile"]') != "${1}" ]]; then
    echo "ERROR! Command was not successful."
    return 1
  fi
  return 0
}

#-------------------------------------------------------
# Function: restartService()
#-------------------------------------------------------
restartService() {
  log "restartService()[service]: ${1}"

  OUT=$(restCall "PATCH" "/tm/sys/service/~${1}" "{\"reinit\":true}")
  log "restartService(): `echo $OUT`"
  if [ "${OUT}x" != "x" ] ; then
    echo "ERROR! The service may not exist or may not have been restarted ($OUT)"
    return 1
  fi
  return 0
}

#-------------------------------------------------------
# Function: uploadFile()
#   Upload file to F5 BIG-IP
# $1 => Name of file to upload
# $2 => Destination file name
#-------------------------------------------------------
uploadFile() {
  log "uploadFile()[Upload File]: ${1}"

  if [ ! -r ${1} ] ; then
    return 1
  fi

  declare -i CHUNK_SIZE
  declare -i FILESIZE
  declare -i TMP_FILESIZE
  declare -i BYTES_START
  declare -i BYTES_END

  FILENAME=`basename ${1}`
  CHUNK_SIZE=$((512 * 1024))
  FILESIZE=`stat -L -c%s ${1}`
  TMP_FILESIZE=0
  BYTES_START=0
  TMP_FILE=`mktemp`

  if [ ${FILESIZE} -le ${CHUNK_SIZE} ] ; then
    OUT=$(/bin/bash -c "${CURL} -s --insecure -X POST --data-binary '@${1}' --user '${BIGIP_USERNAME}:${BIGIP_PASSWORD}' -H 'Content-Type: application/octet-stream' -H 'Content-Range: ${BYTES_START}-$((${FILESIZE} - 1))/${FILESIZE}' 'https://${BIGIP_DEVICE}/mgmt/shared/file-transfer/uploads/${2}'")
    log "${CURL} -s --insecure -X POST --data-binary '@${1}' --user '${BIGIP_USERNAME}:${BIGIP_PASSWORD}' -H 'Content-Type: application/octet-stream' -H 'Content-Range: ${BYTES_START}-$((${FILESIZE} - 1))/${FILESIZE}' 'https://${BIGIP_DEVICE}/mgmt/shared/file-transfer/uploads/${2}'"
  else
    TMP_FILE=`mktemp`
    while [ ${BYTES_START} -le ${FILESIZE} ] ; do
      echo -n '' > ${TMP_FILE}
      dd if="${1}" skip=${BYTES_START} bs=${CHUNK_SIZE} count=1 of="${TMP_FILE}"
      TMP_FILESIZE=`stat -L -c%s ${TMP_FILE}`
      if [ $((${BYTES_START} + ${CHUNK_SIZE})) -gt ${TMP_FILESIZE} ] ; then
        BYTES_END=${FILESIZE}
      else
        BYTES_END=$((${BYTES_START} + ${TMP_FILESIZE}))
      fi
      OUT=$(/bin/bash -c "${CURL} -s --insecure -X POST --data-binary '@${TMP_FILE}' --user '${BIGIP_USERNAME}:${BIGIP_PASSWORD}' -H 'Content-Type: application/octet-stream' -H 'Content-Range: ${BYTES_START}-$((${BYTES_END} - 1))/${FILESIZE}' 'https://${BIGIP_DEVICE}/mgmt/shared/file-transfer/uploads/${2}'")
      log "${CURL} -s --insecure -X POST --data-binary '@${TMP_FILE}' --user '${BIGIP_USERNAME}:${BIGIP_PASSWORD}' -H 'Content-Type: application/octet-stream' -H 'Content-Range: ${BYTES_START}-$((${BYTES_END} - 1))/${FILESIZE}' 'https://${BIGIP_DEVICE}/mgmt/shared/file-transfer/uploads/${2}'"
      BYTES_START=${BYTES_END}
    done
  fi

  if [ "${TMP_FILE}x" != "x" ] && test -e "${TMP_FILE}" ; then
    rm -f "${TMP_FILE}"
  fi

  ##  Overwrite the old records list with the new one.
  # OUT=$(restCall "POST" "/mgmt/shared/file-transfer/uploads/~${BIGIP_Partition}~${1}" "{ \"records\": ${TT} }")
  log "uploadFile()[Upload results]: `echo $OUT | python -mjson.tool`"

  return 0
}

deploy_cert() {
    local DOMAIN="${1}" KEYFILE="${2}" FULLCHAINFILE="${4}"

    # This hook is called once for each certificate that has been
    # produced. Here you might, for instance, copy your new certificates
    # to service-specific locations and reload the service.
    #
    # Parameters:
    # - DOMAIN
    #   The primary domain name, i.e. the certificate common
    #   name (CN).
    # - KEYFILE
    #   The path of the file containing the private key.
    # - FULLCHAINFILE
    #   The path of the file containing the full certificate chain.

    echo "NOTE: Deploying management interface certs and key to F5 BIG-IP (${DOMAIN}#${KEYFILE}#${FULLCHAINFILE})"

    CERTFILE_NAME="${DOMAIN}.crt"
    KEYFILE_NAME="${DOMAIN}.key"
    FULLCHAINFILE_NAME="${DOMAIN}-FULLCHAIN.crt"
    CHAINFILE_NAME="${DOMAIN}-CHAIN.crt"

    echo "NOTE: Uploading full certificate chain and key"

    if [ -r ${KEYFILE} ] ; then
        OUT=$(uploadFile ${KEYFILE} ${DOMAIN}.key)
        if ! $OUT; then
          echo "Error: Certificate for ${DOMAIN} was not uploaded correctly!"
          exit 1
        else
          OUT=$(runBashCommand "cp /var/config/rest/downloads/${DOMAIN}.key /etc/httpd/conf/ssl.key/${DOMAIN}.key")
        fi
    else
        echo "Error: File ${KEYFILE} does not exist or is unreadable!"
        exit 1
    fi

    if [ -r ${FULLCHAINFILE} ] ; then
        OUT=$(uploadFile ${FULLCHAINFILE} ${DOMAIN}-FULLCHAIN.crt)
        if ! $OUT; then
          echo "Error: Certificate for ${DOMAIN} was not uploaded correctly!"
          exit 1
        else
          OUT=$(runBashCommand "cp /var/config/rest/downloads/${DOMAIN}-FULLCHAIN.crt /etc/httpd/conf/ssl.crt/${DOMAIN}.crt")
        fi
    else
        echo "Error: File ${FULLCHAINFILE} does not exist or is unreadable!"
        exit 1
    fi

    # cleanup upload files
    OUT=$(runBashCommand "rm -fv /var/config/rest/downloads/${DOMAIN}.key /var/config/rest/downloads/${DOMAIN}-FULLCHAIN.crt")
    echo "NOTE: Removed uploaded files ($OUT)"

    # TODO add validation command to check all files are in place correctly before modifying httpd config

    # modify httpd config
    OUT=$(modifyHttpdCerts /etc/httpd/conf/ssl.crt/${DOMAIN}.crt /etc/httpd/conf/ssl.key/${DOMAIN}.key)
    echo "NOTE: Modified httpd config ($OUT)"

    # restart service to use new cert/key
    OUT=$(restartService "httpd")
    echo "NOTE: Restarted httpd service ($OUT)"
}

HANDLER="$1"; shift
if [ -n "$(type -t $HANDLER)" ] && [ "$(type -t $HANDLER)" = function ]; then
  "$HANDLER" "$@"
fi

# EOF
